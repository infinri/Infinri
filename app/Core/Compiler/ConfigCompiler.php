<?php declare(strict_types=1);

/**
 * Infinri Framework
 *
 * @copyright Copyright (c) 2024-2025 Lucio Saldivar / Infinri
 * @license   Proprietary - All Rights Reserved
 *
 * This source code is proprietary and confidential. Unauthorized copying,
 * modification, distribution, or use is strictly prohibited. See LICENSE.
 */
namespace App\Core\Compiler;

use App\Core\Support\Arr;

/**
 * Config Compiler
 *
 * Merges module configs into a single cached config file.
 * Generates a static config class for maximum OPcache optimization.
 */
class ConfigCompiler extends AbstractCompiler
{
    protected function getDefaultCachePath(): string
    {
        return $this->basePath . '/var/cache/config.php';
    }

    public function compile(): array
    {
        $config = [];
        $config = $this->loadModuleConfigs($config);
        $config = $this->loadAppConfig($config);

        // Pre-flatten config for O(1) dot-notation access
        $flat = Arr::dot($config);
        $config['_flat'] = $flat;

        // Save traditional cache (for fallback/compatibility)
        $this->saveToCache($config, 'Compiled Config');

        // Generate static config class for maximum performance
        // This is THE clever optimization - OPcache interns the static array
        $this->generateStaticConfigClass($flat, $config);

        return $config;
    }

    /**
     * Generate a static config class for OPcache optimization
     *
     * Why this is fast:
     * 1. Static class properties are stored in OPcache's interned strings table
     * 2. Access is a single FETCH_STATIC_PROP_R opcode - no function calls
     * 3. The array never needs to be "loaded" - it's already in shared memory
     * 4. Zero boot cost after first compilation
     */
    protected function generateStaticConfigClass(array $flat, array $nested): void
    {
        $staticClassPath = $this->basePath . '/var/cache/CompiledConfig.php';

        $code = "<?php\n\n";
        $code .= "declare(strict_types=1);\n\n";
        $code .= "namespace App\\Core\\Config;\n\n";
        $code .= "/**\n";
        $code .= " * Auto-generated static config class\n";
        $code .= " * \n";
        $code .= " * DO NOT EDIT - Generated by ConfigCompiler\n";
        $code .= " * Generated: " . date('Y-m-d H:i:s') . "\n";
        $code .= " * \n";
        $code .= " * This class provides O(1) config access via OPcache optimization.\n";
        $code .= " * The static arrays are interned in shared memory after first load.\n";
        $code .= " */\n";
        $code .= "final class CompiledConfig\n";
        $code .= "{\n";
        $code .= "    /**\n";
        $code .= "     * Flattened config for O(1) dot-notation access\n";
        $code .= "     * Access: CompiledConfig::\$flat['app.name']\n";
        $code .= "     */\n";
        $code .= "    public static array \$flat = " . $this->exportArray($flat) . ";\n\n";
        $code .= "    /**\n";
        $code .= "     * Full nested config (without _flat key)\n";
        $code .= "     */\n";

        // Remove _flat from nested to avoid duplication
        unset($nested['_flat']);
        $code .= "    public static array \$nested = " . $this->exportArray($nested) . ";\n\n";

        $code .= "    /**\n";
        $code .= "     * Get config value - O(1) lookup\n";
        $code .= "     */\n";
        $code .= "    public static function get(string \$key, mixed \$default = null): mixed\n";
        $code .= "    {\n";
        $code .= "        return self::\$flat[\$key] ?? \$default;\n";
        $code .= "    }\n\n";

        $code .= "    /**\n";
        $code .= "     * Check if config key exists - O(1) lookup\n";
        $code .= "     */\n";
        $code .= "    public static function has(string \$key): bool\n";
        $code .= "    {\n";
        $code .= "        return isset(self::\$flat[\$key]);\n";
        $code .= "    }\n";
        $code .= "}\n";

        // Atomic write
        $dir = dirname($staticClassPath);
        if (! is_dir($dir)) {
            mkdir($dir, 0o755, true);
        }

        $tempFile = $staticClassPath . '.tmp.' . getmypid();
        file_put_contents($tempFile, $code);
        rename($tempFile, $staticClassPath);

        // Pre-compile with OPcache if available and enabled
        if (function_exists('opcache_compile_file')
            && function_exists('opcache_get_status')
            && opcache_get_status(false) !== false
        ) {
            opcache_compile_file($staticClassPath);
        }
    }

    /**
     * Export array to valid PHP code
     * More compact than var_export for large arrays
     */
    protected function exportArray(array $array, int $indent = 2): string
    {
        $items = [];
        $isAssoc = array_keys($array) !== range(0, count($array) - 1);

        foreach ($array as $key => $value) {
            $prefix = str_repeat('    ', $indent);
            $keyStr = $isAssoc ? var_export($key, true) . ' => ' : '';

            if (is_array($value)) {
                $items[] = $prefix . $keyStr . $this->exportArray($value, $indent + 1);
            } elseif (is_string($value)) {
                $items[] = $prefix . $keyStr . var_export($value, true);
            } elseif (is_bool($value)) {
                $items[] = $prefix . $keyStr . ($value ? 'true' : 'false');
            } elseif (is_null($value)) {
                $items[] = $prefix . $keyStr . 'null';
            } else {
                $items[] = $prefix . $keyStr . var_export($value, true);
            }
        }

        if ($items === []) {
            return '[]';
        }

        $baseIndent = str_repeat('    ', $indent - 1);

        return "[\n" . implode(",\n", $items) . ",\n" . $baseIndent . ']';
    }

    protected function loadModuleConfigs(array $config): array
    {
        $this->registry->load();

        foreach ($this->registry->getEnabled() as $module) {
            $moduleConfig = $module->loadConfig();

            if ($moduleConfig !== []) {
                $config['modules'][$module->name] = $moduleConfig;

                if (isset($moduleConfig['_global'])) {
                    $config = Arr::mergeRecursive($config, $moduleConfig['_global']);
                    unset($config['modules'][$module->name]['_global']);
                }
            }
        }

        return $config;
    }

    protected function loadAppConfig(array $config): array
    {
        $appConfigPath = $this->basePath . '/app/config.php';

        if (file_exists($appConfigPath)) {
            $appConfig = require $appConfigPath;

            if (is_array($appConfig)) {
                $config = Arr::mergeRecursive($config, $appConfig);
            }
        }

        return $config;
    }
}
