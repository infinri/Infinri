#!/usr/bin/env php
<?php
declare(strict_types=1);

/**
 * Portfolio Setup CLI
 * 
 * Interactive setup and maintenance commands for the portfolio project
 * 
 * Usage:
 *   ./bin/setup install      (or s:i)  - Interactive project setup
 *   ./bin/setup upgrade      (or s:up) - Build assets and prepare for deployment
 *   ./bin/setup permissions  (or s:p)  - Fix file permissions
 *   ./bin/setup help         (or -h)   - Show help
 */

// Colors for terminal output
class Colors {
    const RESET = "\033[0m";
    const RED = "\033[31m";
    const GREEN = "\033[32m";
    const YELLOW = "\033[33m";
    const BLUE = "\033[34m";
    const MAGENTA = "\033[35m";
    const CYAN = "\033[36m";
    const BOLD = "\033[1m";
}

class Setup {
    private string $rootDir;
    private string $envFile;
    
    public function __construct() {
        $this->rootDir = dirname(__DIR__);
        $this->envFile = $this->rootDir . '/.env';
    }
    
    /**
     * Main command router
     */
    public function run(array $args): int {
        $command = $args[1] ?? 'help';
        
        // Handle shorthand commands and namespace variations
        $commandMap = [
            's:i' => 'setup:install',
            's:up' => 'setup:upgrade',
            's:p' => 'setup:permissions',
            'install' => 'setup:install',        // Allow without namespace
            'upgrade' => 'setup:upgrade',        // Allow without namespace
            'permissions' => 'setup:permissions', // Allow without namespace
            '-h' => 'help',
            '--help' => 'help'
        ];
        
        $command = $commandMap[$command] ?? $command;
        
        switch ($command) {
            case 'setup:install':
                return $this->install();
            case 'setup:upgrade':
                return $this->upgrade();
            case 'setup:permissions':
                return $this->fixPermissions();
            case 'help':
                $this->showHelp();
                return 0;
            default:
                $this->error("Unknown command: $command");
                $this->showHelp();
                return 1;
        }
    }
    
    /**
     * Interactive installation and .env setup
     */
    private function install(): int {
        $this->header("Portfolio Project Installation");
        
        echo "\n";
        $this->info("This wizard will help you set up your portfolio project.");
        echo "\n";
        
        // Check if .env already exists
        if (file_exists($this->envFile)) {
            $this->warning(".env file already exists!");
            $overwrite = $this->confirm("Do you want to overwrite it?", false);
            
            if (!$overwrite) {
                $this->info("Installation cancelled.");
                return 0;
            }
            
            // Backup existing .env
            $backup = $this->envFile . '.backup.' . date('Y-m-d_H-i-s');
            copy($this->envFile, $backup);
            $this->success("Existing .env backed up to: " . basename($backup));
            echo "\n";
        }
        
        // Collect configuration
        $config = $this->collectConfiguration();
        
        // Create .env file
        $this->info("\nCreating .env file...");
        $this->createEnvFile($config);
        $this->success(".env file created successfully!");
        
        // Fix permissions
        echo "\n";
        $this->info("Setting file permissions...");
        $this->fixPermissions();
        
        // Check dependencies
        echo "\n";
        $this->info("Checking dependencies...");
        $this->checkDependencies();
        
        // Final message
        echo "\n";
        $this->header("Installation Complete!");
        $this->success("Your portfolio project is ready to use.");
        echo "\n";
        $this->info("Next steps:");
        echo "  1. Run: " . Colors::CYAN . "./bin/setup upgrade" . Colors::RESET . " (or s:up) to build assets\n";
        echo "  2. Start server: " . Colors::CYAN . "caddy run" . Colors::RESET . "\n";
        echo "  3. Visit: " . Colors::CYAN . "http://localhost:8080" . Colors::RESET . "\n";
        echo "\n";
        
        return 0;
    }
    
    /**
     * Collect configuration from user
     */
    private function collectConfiguration(): array {
        $config = [];
        
        // Environment
        $this->section("Environment Configuration");
        $config['APP_ENV'] = $this->choice(
            "What environment is this?",
            ['development', 'production'],
            'development'
        );
        
        // Site information
        $this->section("Site Information");
        $config['SITE_NAME'] = $this->ask("Site name", "Infinri Portfolio");
        
        // Accept user-friendly domain input
        $this->info("Enter your domain (e.g., 'infinri.com' or 'localhost')");
        $userInput = $this->ask("Site URL", "localhost");
        $config['SITE_URL'] = $this->normalizeSiteUrl($userInput);
        
        // Show what we normalized it to
        if ($userInput !== $config['SITE_URL']) {
            $this->success("→ Normalized to: " . $config['SITE_URL']);
        }
        
        // Security
        $this->section("Security Settings");
        $config['CSRF_ENABLED'] = $this->confirm("Enable CSRF protection?", true) ? 'true' : 'false';
        
        // HTTPS_ONLY should default based on environment
        $httpsDefault = ($config['APP_ENV'] === 'production');
        $this->info($httpsDefault ? "Production requires HTTPS" : "Development typically uses HTTP");
        $config['HTTPS_ONLY'] = $this->confirm("HTTPS only?", $httpsDefault) ? 'true' : 'false';
        
        // Session - Auto-derive domain from SITE_URL
        $this->section("Session Configuration");
        $config['SESSION_LIFETIME'] = $this->ask("Session lifetime (seconds)", "7200");
        
        // Smart default for SESSION_DOMAIN based on SITE_URL
        $defaultSessionDomain = $this->deriveSessionDomain($config['SITE_URL']);
        $this->info("Suggested session domain: " . ($defaultSessionDomain ?: "(empty - works for localhost)"));
        $customDomain = $this->ask("Override session domain? (press Enter to use suggestion)", "");
        $config['SESSION_DOMAIN'] = $customDomain ?: $defaultSessionDomain;
        
        // Version - Auto-generate timestamp
        $config['APP_VERSION'] = time();
        
        return $config;
    }
    
    /**
     * Normalize user-friendly SITE_URL input
     * 
     * Accepts:
     * - infinri.com → https://infinri.com
     * - www.infinri.com → https://www.infinri.com
     * - localhost → http://localhost:8080
     * - localhost:3000 → http://localhost:3000
     * - https://infinri.com → https://infinri.com (no change)
     */
    private function normalizeSiteUrl(string $input): string {
        $input = trim($input);
        
        // Already has protocol
        if (preg_match('#^https?://#i', $input)) {
            return $input;
        }
        
        // Localhost without port - add default
        if (preg_match('#^(localhost|127\.0\.0\.1|::1)$#i', $input)) {
            return 'http://' . $input . ':8080';
        }
        
        // Localhost with port - use http
        if (preg_match('#^(localhost|127\.0\.0\.1|::1):\d+$#i', $input)) {
            return 'http://' . $input;
        }
        
        // Production domain - use https
        return 'https://' . $input;
    }
    
    /**
     * Derive SESSION_DOMAIN from SITE_URL
     * 
     * Best practices:
     * - localhost/127.0.0.1: empty (default to current host)
     * - Production domain: .example.com (with leading dot for subdomain sharing)
     * - Port numbers: ignored
     */
    private function deriveSessionDomain(string $siteUrl): string {
        // Parse the URL
        $parsed = parse_url($siteUrl);
        if (!$parsed || !isset($parsed['host'])) {
            return '';
        }
        
        $host = strtolower($parsed['host']);
        
        // Localhost or IP address - use empty (default)
        if ($host === 'localhost' || 
            $host === '127.0.0.1' || 
            $host === '::1' ||
            filter_var($host, FILTER_VALIDATE_IP)) {
            return '';
        }
        
        // Production domain - add leading dot for subdomain cookie sharing
        // Example: example.com -> .example.com
        // Example: subdomain.example.com -> .example.com
        // This allows cookies to work on www.example.com, api.example.com, etc.
        
        // Extract base domain (last 2 parts for .com, .net, etc.)
        $parts = explode('.', $host);
        $count = count($parts);
        
        if ($count >= 2) {
            // Get last 2 parts (example.com from subdomain.example.com)
            $baseDomain = $parts[$count - 2] . '.' . $parts[$count - 1];
            return '.' . $baseDomain;
        }
        
        // Single word domain (rare) - use as-is with leading dot
        return '.' . $host;
    }
    
    /**
     * Create .env file from configuration
     */
    private function createEnvFile(array $config): void {
        $content = <<<ENV
# Portfolio Project Configuration
# Generated: {DATE}

# Environment (development or production)
APP_ENV={APP_ENV}

# Site Information
SITE_NAME="{SITE_NAME}"
SITE_URL={SITE_URL}

# Security
CSRF_ENABLED={CSRF_ENABLED}
HTTPS_ONLY={HTTPS_ONLY}

# Session Configuration
SESSION_LIFETIME={SESSION_LIFETIME}
SESSION_DOMAIN={SESSION_DOMAIN}

# Cache Busting Version
APP_VERSION={APP_VERSION}

ENV;
        
        // Replace placeholders
        $content = str_replace('{DATE}', date('Y-m-d H:i:s'), $content);
        foreach ($config as $key => $value) {
            $content = str_replace('{' . $key . '}', $value, $content);
        }
        
        file_put_contents($this->envFile, $content);
        chmod($this->envFile, 0644); // Readable by PHP-FPM, not writable by others
    }
    
    /**
     * Build assets and prepare for deployment
     */
    private function upgrade(): int {
        $this->header("Portfolio Project Upgrade");
        
        echo "\n";
        $this->info("Building assets and preparing for deployment...");
        echo "\n";
        
        // Check if node_modules exists
        if (!is_dir($this->rootDir . '/node_modules')) {
            $this->warning("node_modules not found. Installing dependencies...");
            $result = $this->execCommand('npm install', 'Installing npm packages');
            if ($result !== 0) {
                return $result;
            }
            echo "\n";
        }
        
        // Build assets with minification
        $this->info("Building and minifying assets...");
        $this->info("→ Running: npm run build");
        $result = $this->execCommand('npm run build', 'Minifying CSS and JS bundles');
        if ($result !== 0) {
            return $result;
        }
        
        echo "\n";
        
        // Verify build output
        $this->info("Verifying minified bundles...");
        $distDir = $this->rootDir . '/pub/assets/dist';
        $requiredFiles = ['all.min.css', 'all.min.js'];
        
        $totalOriginal = 0;
        $totalMinified = 0;
        
        foreach ($requiredFiles as $file) {
            $path = $distDir . '/' . $file;
            if (file_exists($path)) {
                $size = filesize($path);
                $totalMinified += $size;
                $formatted = $this->formatBytes($size);
                $this->success("✓ $file → $formatted (minified)");
            } else {
                $this->error("✗ $file not found!");
                return 1;
            }
        }
        
        // Show total savings
        echo "\n";
        $this->success("Total minified size: " . $this->formatBytes($totalMinified));
        $this->info("Assets are production-ready!");
        
        echo "\n";
        
        // Clean up test files for production
        $this->info("Cleaning up test files for production...");
        $this->cleanTestFiles();
        
        echo "\n";
        
        // Fix permissions
        $this->info("Setting file permissions...");
        $this->fixPermissions();
        
        echo "\n";
        $this->header("Upgrade Complete!");
        $this->success("Your portfolio is ready for deployment.");
        echo "\n";
        $this->info("Deploy checklist:");
        echo "  ✓ Assets built and minified\n";
        echo "  ✓ Test files removed\n";
        echo "  ✓ File permissions set\n";
        echo "  ✓ Production ready\n";
        echo "\n";
        
        return 0;
    }
    
    /**
     * Clean test files for production deployment
     * Only runs if APP_ENV=production to protect development environment
     */
    private function cleanTestFiles(): void {
        // Safety check - only clean test files in production
        $appEnv = getenv('APP_ENV') ?: 'development';
        
        if ($appEnv !== 'production') {
            $this->warning("Skipping test file cleanup (APP_ENV={$appEnv})");
            $this->info("Test files are only removed in production mode.");
            $this->info("To clean test files, set APP_ENV=production in .env");
            return;
        }
        
        $testPaths = [
            'tests',
            'phpunit.xml',
            'phpunit.xml.dist',
            '.phpunit.result.cache',
            'phpstan.neon',
            'phpstan.neon.dist',
        ];
        
        $removedCount = 0;
        $savedSpace = 0;
        
        foreach ($testPaths as $path) {
            $fullPath = $this->rootDir . '/' . $path;
            
            if (!file_exists($fullPath)) {
                continue;
            }
            
            // Calculate size before removal
            if (is_dir($fullPath)) {
                $size = $this->getDirectorySize($fullPath);
                $this->execCommand("rm -rf " . escapeshellarg($fullPath), "Removing tests directory");
                $this->success("✓ Removed tests/ directory (" . $this->formatBytes($size) . ")");
                $savedSpace += $size;
            } else {
                $size = filesize($fullPath);
                unlink($fullPath);
                $this->success("✓ Removed " . basename($fullPath) . " (" . $this->formatBytes($size) . ")");
                $savedSpace += $size;
            }
            
            $removedCount++;
        }
        
        if ($removedCount > 0) {
            echo "\n";
            $this->success("Total space saved: " . $this->formatBytes($savedSpace));
            $this->info("Production build is now " . $this->formatBytes($savedSpace) . " slimmer!");
        } else {
            $this->info("No test files found (already clean)");
        }
    }
    
    /**
     * Calculate directory size recursively
     */
    private function getDirectorySize(string $path): int {
        $size = 0;
        $files = new \RecursiveIteratorIterator(
            new \RecursiveDirectoryIterator($path, \RecursiveDirectoryIterator::SKIP_DOTS)
        );
        
        foreach ($files as $file) {
            if ($file->isFile()) {
                $size += $file->getSize();
            }
        }
        
        return $size;
    }
    
    /**
     * Fix file permissions
     */
    private function fixPermissions(): int {
        $this->info("Setting permissions...");
        
        $permissions = [
            'var/log' => 0755,
            'var/cache' => 0755,
            'var/sessions' => 0700,
            'pub/assets/dist' => 0755,
            '.env' => 0644,  // PHP-FPM needs read access
        ];
        
        foreach ($permissions as $path => $mode) {
            $fullPath = $this->rootDir . '/' . $path;
            
            if (!file_exists($fullPath)) {
                mkdir($fullPath, $mode, true);
                $this->success("✓ Created $path");
            } else {
                chmod($fullPath, $mode);
                $this->success("✓ Set $path to " . decoct($mode));
            }
        }
        
        // Make bin scripts executable
        $binScripts = glob($this->rootDir . '/bin/*');
        foreach ($binScripts as $script) {
            chmod($script, 0755);
        }
        $this->success("✓ Made bin scripts executable");
        
        return 0;
    }
    
    /**
     * Check dependencies
     */
    private function checkDependencies(): void {
        $checks = [
            'PHP' => ['php', '--version'],
            'Node.js' => ['node', '--version'],
            'npm' => ['npm', '--version'],
            'Caddy' => ['caddy', 'version'],
        ];
        
        foreach ($checks as $name => $command) {
            $output = @shell_exec(implode(' ', $command) . ' 2>&1');
            if ($output) {
                preg_match('/[\d\.]+/', $output, $matches);
                $version = $matches[0] ?? 'installed';
                $this->success("✓ $name ($version)");
            } else {
                $this->warning("✗ $name not found");
            }
        }
    }
    
    /**
     * Execute a command with visual feedback
     */
    private function execCommand(string $command, string $description): int {
        echo "  → $description...\n";
        
        $descriptorspec = [
            0 => ['pipe', 'r'],
            1 => ['pipe', 'w'],
            2 => ['pipe', 'w']
        ];
        
        $process = proc_open(
            $command,
            $descriptorspec,
            $pipes,
            $this->rootDir
        );
        
        if (!is_resource($process)) {
            $this->error("Failed to execute: $command");
            return 1;
        }
        
        fclose($pipes[0]);
        
        // Read output
        $output = stream_get_contents($pipes[1]);
        $errors = stream_get_contents($pipes[2]);
        
        fclose($pipes[1]);
        fclose($pipes[2]);
        
        $returnCode = proc_close($process);
        
        if ($returnCode === 0) {
            $this->success("✓ $description completed");
            return 0;
        } else {
            $this->error("✗ $description failed");
            if ($errors) {
                echo Colors::RED . $errors . Colors::RESET . "\n";
            }
            return $returnCode;
        }
    }
    
    // ==================== UI Helpers ====================
    
    private function header(string $text): void {
        $length = strlen($text) + 4;
        $border = str_repeat('═', $length);
        echo "\n" . Colors::BOLD . Colors::CYAN . "╔{$border}╗\n";
        echo "║  {$text}  ║\n";
        echo "╚{$border}╝" . Colors::RESET . "\n";
    }
    
    private function section(string $text): void {
        echo "\n" . Colors::BOLD . Colors::MAGENTA . "▸ $text" . Colors::RESET . "\n";
    }
    
    private function success(string $message): void {
        echo Colors::GREEN . $message . Colors::RESET . "\n";
    }
    
    private function info(string $message): void {
        echo Colors::BLUE . $message . Colors::RESET . "\n";
    }
    
    private function warning(string $message): void {
        echo Colors::YELLOW . "⚠ $message" . Colors::RESET . "\n";
    }
    
    private function error(string $message): void {
        echo Colors::RED . "✗ ERROR: $message" . Colors::RESET . "\n";
    }
    
    private function ask(string $question, string $default = ''): string {
        $defaultText = $default ? " [$default]" : '';
        echo Colors::CYAN . "  $question$defaultText: " . Colors::RESET;
        
        $handle = fopen('php://stdin', 'r');
        $line = trim(fgets($handle));
        fclose($handle);
        
        return $line ?: $default;
    }
    
    private function choice(string $question, array $options, string $default): string {
        echo Colors::CYAN . "  $question" . Colors::RESET . "\n";
        foreach ($options as $i => $option) {
            $marker = $option === $default ? '*' : ' ';
            echo "    $marker " . ($i + 1) . ". $option\n";
        }
        echo Colors::CYAN . "  Choice [" . (array_search($default, $options) + 1) . "]: " . Colors::RESET;
        
        $handle = fopen('php://stdin', 'r');
        $line = trim(fgets($handle));
        fclose($handle);
        
        if ($line === '') {
            return $default;
        }
        
        $index = (int)$line - 1;
        return $options[$index] ?? $default;
    }
    
    private function confirm(string $question, bool $default = true): bool {
        $defaultText = $default ? 'Y/n' : 'y/N';
        echo Colors::CYAN . "  $question [$defaultText]: " . Colors::RESET;
        
        $handle = fopen('php://stdin', 'r');
        $line = strtolower(trim(fgets($handle)));
        fclose($handle);
        
        if ($line === '') {
            return $default;
        }
        
        return in_array($line, ['y', 'yes', '1', 'true']);
    }
    
    private function formatBytes(int $bytes): string {
        $units = ['B', 'KB', 'MB', 'GB'];
        $bytes = max($bytes, 0);
        $pow = floor(($bytes ? log($bytes) : 0) / log(1024));
        $pow = min($pow, count($units) - 1);
        $bytes /= pow(1024, $pow);
        
        return round($bytes, 2) . ' ' . $units[$pow];
    }
    
    private function showHelp(): void {
        echo <<<HELP

{$this->colorize('Portfolio Console', Colors::BOLD . Colors::CYAN)}

{$this->colorize('Usage:', Colors::BOLD)}
  bin/console <command>

{$this->colorize('Commands:', Colors::BOLD)}
  {$this->colorize('setup:install', Colors::GREEN)} (s:i)      Interactive project setup
                      - Configure .env file
                      - Set file permissions
                      - Check dependencies
                      
  {$this->colorize('setup:upgrade', Colors::GREEN)} (s:up)     Build assets and prepare for deployment
                      - Install npm dependencies
                      - Build minified assets
                      - Verify build output
                      
  {$this->colorize('setup:permissions', Colors::GREEN)} (s:p)  Fix file permissions
                      - Set correct directory permissions
                      - Make scripts executable
                      
  {$this->colorize('help', Colors::GREEN)} (-h, --help)  Show this help message

{$this->colorize('Examples:', Colors::BOLD)}
  bin/console setup:install    # Interactive setup
  bin/console s:i              # Same as above (shorthand)
  bin/console setup:upgrade    # Build for production
  bin/console s:up             # Same as above (shorthand)

{$this->colorize('Workflow:', Colors::BOLD)}
  1. First time: bin/console setup:install
  2. Build assets: bin/console setup:upgrade
  3. Start server: caddy run
  4. Deploy: Push to production

HELP;
    }
    
    private function colorize(string $text, string $color): string {
        return $color . $text . Colors::RESET;
    }
}

// Run the setup
$setup = new Setup();
exit($setup->run($argv));
